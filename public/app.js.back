window.DND = window.DND || { draggingId: null, source: null, dropIndex: null, item: null };
window.DRAG_LOCK = false;

async function fetchJSON(url, opts){
  const r = await fetch(url, opts);
  if (!r.ok) throw new Error(await r.text());
  return r.json();
}

function showLoading(show){
  const ov = document.getElementById('loadingOverlay');
  const main = document.querySelector('main');
  if (!ov || !main) return;
  ov.classList.toggle('hidden', !show);
  main.classList.toggle('pointer-events-none', show);
  main.classList.toggle('opacity-50', show);
}

function showToast(msg, type){
  let host = document.getElementById('toastHost');
  if (!host){
    host = document.createElement('div');
    host.id = 'toastHost';
    host.className = 'fixed top-4 right-4 z-[9999] space-y-2';
    document.body.appendChild(host);
  }
  const note = document.createElement('div');
  const color = type==='error' ? 'bg-red-600' : (type==='warn' ? 'bg-amber-600' : 'bg-emerald-600');
  note.className = color + ' text-white px-4 py-3 rounded-xl shadow-lg transition opacity-0';
  note.textContent = msg;
  host.appendChild(note);
  requestAnimationFrame(()=>note.classList.remove('opacity-0'));
  setTimeout(()=>{ note.classList.add('opacity-0'); setTimeout(()=>note.remove(), 300); }, 2200);
}

let ALL_CH = [];
let EPG_IDX = [];
let ID_NAMES = [];

// === Robustheits-Helpers ===
function toArray(val){
  if (Array.isArray(val)) return val;
  if (val && typeof val === 'object') return Object.values(val);
  return [];
}

function parseM3U(text){
  const lines = String(text || '').split(/\r?\n/);
  const arr = [];
  let cur = {};
  for (const lineRaw of lines){
    const line = lineRaw.trim();
    if (!line) continue;
    if (line.startsWith('#EXTINF:')){
      const nameMatch = line.split(',').slice(-1)[0];
      const name = nameMatch ? nameMatch.trim() : 'Channel';
      const groupMatch = /group-title="([^"]*)"/i.exec(line);
      const group = groupMatch ? groupMatch[1] : null;
      const tvgIdMatch = /tvg-id="([^"]*)"/i.exec(line);
      const tvg_id = tvgIdMatch ? tvgIdMatch[1] : null;
      const logoMatch = /tvg-logo="([^"]*)"/i.exec(line);
      const logo = logoMatch ? logoMatch[1] : null;
      const chnoMatch = /tvg-chno="([^"]*)"/i.exec(line);
      const chno = chnoMatch ? chnoMatch[1] : null;
      cur = { name, group_name: group, tvg_id, logo, number: chno ? Number(chno) : null };
    } else if (!line.startsWith('#')){
      arr.push({ ...cur, url: line });
      cur = {};
    }
  }
  return arr;
}

// ---- Paging-State + UI ----
let PAGING = { page: 1, limit: 100, total: 0, pages: 0 };

function ensurePagerBar(){
  const host = document.getElementById('groupedChannels');
  if (!host) return;
  // Falls schon vorhanden, nichts tun
  if (document.getElementById('pagerBar')) return;

  const bar = document.createElement('div');
  bar.id = 'pagerBar';
  bar.className = 'mb-3 flex items-center gap-3 text-sm';
  bar.innerHTML = `
    <button id="pagerPrev" class="px-3 py-1 rounded bg-slate-800 hover:bg-slate-700">◀</button>
    <span id="pagerInfo" class="text-slate-300">Seite 1 / 1 • 0 Einträge</span>
    <button id="pagerNext" class="px-3 py-1 rounded bg-slate-800 hover:bg-slate-700">▶</button>
    <span class="ml-3 text-slate-400">Pro Seite:</span>
    <select id="pageSize" class="px-2 py-1 rounded bg-slate-800">
      <option value="50">50</option>
      <option value="100" selected>100</option>
      <option value="200">200</option>
      <option value="500">500</option>
    </select>
  `;
  host.parentElement.insertBefore(bar, host);

  // Events
  document.getElementById('pagerPrev').addEventListener('click', ()=>{
    if (PAGING.page > 1) loadChannelsPage(PAGING.page - 1);
  });
  document.getElementById('pagerNext').addEventListener('click', ()=>{
    if (PAGING.page < PAGING.pages) loadChannelsPage(PAGING.page + 1);
  });
  document.getElementById('pageSize').addEventListener('change', (e)=>{
    PAGING.limit = Number(e.target.value) || 100;
    loadChannelsPage(1);
  });
}

function updatePagerUI(){
  const info = document.getElementById('pagerInfo');
  if (!info) return;
  info.textContent = `Seite ${PAGING.page} / ${Math.max(1,PAGING.pages)} • ${PAGING.total} Einträge`;
  document.getElementById('pagerPrev')?.toggleAttribute('disabled', PAGING.page <= 1);
  document.getElementById('pagerNext')?.toggleAttribute('disabled', PAGING.page >= PAGING.pages);
}

function loadChannelsPage(nextPage){
  return loadChannelsMapping({ page: nextPage, limit: PAGING.limit });
}

let FILTERS = { q: "", group: "" };

function debounce(fn, wait = 250){
  let t; 
  return (...args) => { clearTimeout(t); t = setTimeout(()=>fn(...args), wait); };
}

// ===== Dual-Pane Mapping State =====
let VIEW_MODE = localStorage.getItem('viewMode') || 'dual'; // "dual" oder "grouped"
let LEFT_STATE  = { page: 1, limit: 100, q: '', group: '' }; // Xtream/.m3u
let RIGHT_STATE = { page: 1, limit: 100, q: '' };            // nur enabled
let LEFT_ROWS = [];
let RIGHT_ROWS = [];
let DND = { draggingId: null };

// Robust: API kann Array ODER {page,limit,total,rows} liefern
async function fetchChannelsRobust(params = {}){
  const u = new URL('/api/channels', location.origin);
  for (const [k,v] of Object.entries(params)) if (v!=='' && v!=null) u.searchParams.set(k, String(v));
  const r = await fetch(u, { cache: 'no-cache' });
  const ct = (r.headers.get('content-type')||'').toLowerCase();
  let payload = ct.includes('application/json') ? await r.json()
              : { page: Number(params.page||1), limit: Number(params.limit||100), total: 0, rows: parseM3U(await r.text()) };

  const rows = Array.isArray(payload) ? payload
             : Array.isArray(payload.rows) ? payload.rows
             : [];
  const page  = Number((Array.isArray(payload) ? params.page : payload.page) || 1);
  const limit = Number((Array.isArray(payload) ? params.limit : payload.limit) || rows.length || 100);
  const total = Number((Array.isArray(payload) ? rows.length : payload.total) || rows.length);

  // Normalisieren
  const norm = rows.filter(Boolean).map(ch => ({
    id: ch.id ?? ch.channel_id ?? ch.stream_id ?? null,
    name: ch.name ?? ch.channelName ?? 'Channel',
    group_name: ch.group_name ?? ch.group ?? ch.category_name ?? '',
    tvg_id: ch.tvg_id ?? ch.epg_channel_id ?? '',
    logo: ch.logo ?? ch.tvg_logo ?? '',
    number: (ch.number != null) ? Number(ch.number) : null,
    url: ch.url ?? ch.stream_url ?? '',
    enabled: ch.enabled ?? ch.enable ?? false,
    epg_source: ch.epg_source ?? null,
  })).filter(c => c.url);

  return { page, limit, total, rows: norm };
}

function setViewMode(mode){
  VIEW_MODE = mode;
  localStorage.setItem('viewMode', mode);
}

let GLOBAL_EPG_SOURCES = null;
async function getEpgSourcesCached() {
  if (GLOBAL_EPG_SOURCES) return GLOBAL_EPG_SOURCES;
  try { GLOBAL_EPG_SOURCES = await fetchJSON('/api/epg/sources'); }
  catch { GLOBAL_EPG_SOURCES = []; }
  return GLOBAL_EPG_SOURCES;
}

async function checkWizard(){
  try {
    const s = await fetchJSON('/api/status');
    const hasAnySource = (s.m3u + s.xtream) > 0;
    const w = document.getElementById('setupWizard');
    if (w) w.classList.toggle('hidden', hasAnySource);
  } catch {}
}

async function loadSources(){
  const wrapM = document.getElementById('m3uList'); if (!wrapM) return;
  const data = await fetchJSON('/api/sources');
  const m = data.m3u || []; const x = data.xtream || [];
  const parts = [];
  if (m.length){
    parts.push('<div class="mb-2 font-semibold text-slate-300">M3U Sources</div>');
    for (const s of m){
      parts.push(
        `<div class="flex items-center justify-between text-xs bg-slate-800/60 rounded p-2 mb-1">
          <div class="truncate"><b>${s.name}</b> — ${s.url}</div>
          <button data-type="m3u" data-id="${s.id}" class="delSource px-2 py-1 rounded bg-red-600 hover:bg-red-500">Delete</button>
        </div>`
      );
    }
  }
  if (x.length){
    parts.push('<div class="mt-3 mb-2 font-semibold text-slate-300">Xtream Sources</div>');
    for (const s of x){
      parts.push(
        `<div class="flex items-center justify-between text-xs bg-slate-800/60 rounded p-2 mb-1">
          <div class="truncate"><b>${s.name}</b> — ${s.base_url}</div>
          <button data-type="xtream" data-id="${s.id}" class="delSource px-2 py-1 rounded bg-red-600 hover:bg-red-500">Delete</button>
        </div>`
      );
    }
  }
  wrapM.innerHTML = parts.join('') || 'No sources yet.';
  document.querySelectorAll('.delSource').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const t = btn.getAttribute('data-type'); const id = btn.getAttribute('data-id');
      if (!confirm('Delete this source?')) return;
      await fetchJSON(`/api/sources/${t}/${id}`, { method:'DELETE' });
      await loadSources(); await loadChannelsMapping(); await checkWizard();
    });
  });
}

async function loadEPGIndex(){
  try { 
    const arr = await fetchJSON('/api/epg/channels');
    ID_NAMES = arr;
    // Build fast lookup for suggestions
    EPG_IDX = {};
    for (const it of arr){
      for (const n of (it.names||[])){ EPG_IDX[n.toLowerCase()] = it.id; }
    }
  } catch { EPG_IDX = {}; ID_NAMES = []; }
}

async function loadEPGSources(){
  const host = document.getElementById('epgList'); if (!host) return;
  try{
    const list = await fetchJSON('/api/epg/sources');
    host.innerHTML = list.map(x => {
      const badge = x.status === 'active'
        ? '<span class="ml-2 text-xs px-2 py-1 rounded bg-emerald-700">active</span>'
        : '<span class="ml-2 text-xs px-2 py-1 rounded bg-red-700">pending</span>';
      return `<div class="flex items-center justify-between bg-slate-800/60 rounded p-2">
        <div class="truncate"><b>${x.name}</b> — ${x.url}</div>
        <div>${badge}</div>
      </div>`;
    }).join('') || '<div class="text-slate-400">Keine EPG Quellen.</div>';
  }catch(e){ host.innerHTML = '<div class="text-red-400">Fehler beim Laden der EPG-Liste</div>'; }
}

function groupMap(chs){
  const m = new Map();
  for (const c of chs){
    const g = c.group_name || 'Ungrouped';
    if (!m.has(g)) m.set(g, []);
    m.get(g).push(c);
  }
  return m;
}

function ensureGroupOptions(){
  const sel = document.getElementById('groupFilter'); if (!sel) return;
  const list = Array.isArray(ALL_CH) ? ALL_CH : toArray(ALL_CH);
  const names = Array.from(new Set(list.map(c => c?.group_name).filter(Boolean))).sort();
  sel.innerHTML = '<option value="">Alle Gruppen</option>' + names.map(n => `<option value="${n}">${n}</option>`).join('');
}

function epgSuggest(term){
  const t = (term||'').toLowerCase().trim();
  if (!t) return [];
  const hits = [];
  const seen = new Set();

  // zuerst: Name -> ID (aus EPG_IDX)
  for (const [name,id] of Object.entries(EPG_IDX)){
    if (name.includes(t) && !seen.has(id)) { hits.push({ id, name }); seen.add(id); }
    if (hits.length >= 8) break;
  }

  // zusätzlich: ID enthält Suchbegriff (aus ID_NAMES)
  if (hits.length < 8){
    for (const it of (ID_NAMES||[])){
      const idStr = String(it.id||'').toLowerCase();
      if (idStr.includes(t) && !seen.has(it.id)){
        hits.push({ id: it.id, name: (it.names && it.names[0]) || it.id });
        seen.add(it.id);
      }
      if (hits.length >= 8) break;
    }
  }
  return hits;
}

const applyFilterAndSearch = debounce(()=>{
  const sEl = document.getElementById('searchBox');
  const gEl = document.getElementById('groupFilter');
  FILTERS.q = (sEl?.value || "").trim();
  FILTERS.group = gEl?.value || "";

  // nur EINE Netz-Anfrage (Seite 1), KEIN renderGrouped hier!
  loadChannelsMapping({ page: 1, q: FILTERS.q, group: FILTERS.group });
}, 250);

function renderGrouped(chs){
  const host = document.getElementById('groupedChannels'); if (!host) return;
  host.innerHTML = '';
  const groups = groupMap(chs);
  const sorted = Array.from(groups.entries()).sort((a,b)=>a[0].localeCompare(b[0]));
  for (const [gname, list] of sorted){
    const wrap = document.createElement('div');
    wrap.className = 'rounded-2xl border border-slate-800 overflow-hidden';
    const header = document.createElement('div');
    header.className = 'bg-slate-900 px-4 py-2 flex items-center justify-between cursor-pointer';
    header.innerHTML = `<div class="font-semibold">${gname} <span class="text-xs text-slate-400">(${list.length})</span></div><div>▼</div>`;
    const body = document.createElement('div');
    body.className = 'bg-slate-900/40';
    const inner = document.createElement('div');
    inner.className = 'divide-y divide-slate-800';

    for (const ch of list){
      const row = document.createElement('div');
      row.className = 'p-3 flex items-start justify-between gap-3';
      const left = document.createElement('div');
      left.className = 'flex items-center gap-3 min-w-0';
      left.innerHTML = `<img src="${ch.logo||''}" onerror="this.style.display='none'" class="w-8 h-8 rounded shrink-0" />
        <div class="min-w-0">
          <div class="truncate font-medium">${ch.number ?? ''} ${ch.name}</div>
          <div class="text-xs text-slate-400 truncate">URL: ${ch.url}</div>
          <div class="text-xs ${ch.tvg_id ? 'text-emerald-400' : 'text-amber-400'}">EPG: ${ch.tvg_id || '— nicht zugeordnet —'}</div>
        </div>`;
      const right = document.createElement('div');
      right.className = 'flex items-center gap-2';
      right.innerHTML = `
        <label class="text-xs flex items-center gap-2"><input type="checkbox" class="rowSelect" data-id="${ch.id}"> Wählen</label>
        <select class="epgSourceSel px-2 py-2 rounded bg-slate-800 text-sm"><option value="">Auto/Global</option></select>
        <input type="text" placeholder="EPG suchen…" class="epgSearch px-3 py-2 rounded bg-slate-800 text-sm w-52" data-id="${ch.id}" />
        <button class="assignBtn px-3 py-2 rounded bg-indigo-600 hover:bg-indigo-500 text-sm" data-id="${ch.id}">Zuweisen</button>
        <label class="text-xs flex items-center gap-2 ml-2">
          <input type="checkbox" ${ch.enabled ? 'checked' : ''} data-id="${ch.id}" class="toggleEnabled">
          Enabled
        </label>
      `;

      // populate epg source select
            (async ()=>{
              try {
                const sel = right.querySelector('.epgSourceSel');
                const list = await getEpgSourcesCached();  // <-- Nur 1x geladen und gecached
                for (const it of list){ 
                  const opt = document.createElement('option'); 
                  opt.value = it.name; 
                  opt.textContent = it.name; 
                  sel.appendChild(opt); 
                }
                const d = document.createElement('option'); 
                d.value = 'SF Dummy'; 
                d.textContent = 'SF Dummy'; 
                sel.appendChild(d);
                if (ch.epg_source){ sel.value = ch.epg_source; }
              } catch {}
            })();


      const sugg = document.createElement('div');
      sugg.className = 'text-xs text-slate-300 grid grid-cols-2 gap-2 mt-2 hidden';

      const assign = async ()=>{
        const inp = right.querySelector('.epgSearch');
        const epgSel = right.querySelector('.epgSourceSel');
        const val = (inp && inp.value) ? inp.value.trim() : '';
        if (!val){ showToast('Bitte zuerst EPG-ID eintippen oder wählen', 'warn'); return; }
        await fetchJSON('/api/channels/'+ch.id+'/assign-epg', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ tvg_id: val, epg_source: epgSel?.value||null })
        });
        showToast('EPG zugewiesen');
        await loadChannelsMapping();
      };

      row.querySelector = (sel)=>row.querySelectorAll(sel)[0]; // ensure scope

      right.querySelector('.assignBtn').addEventListener('click', assign);
      right.querySelector('.toggleEnabled').addEventListener('change', async (e)=>{
        await fetchJSON('/api/channels/'+ch.id, {
          method:'PATCH',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ enabled: e.target.checked })
        });
      });
      const epgInput = right.querySelector('.epgSearch');
      epgInput.addEventListener('input', (e)=>{
        const hits = epgSuggest(e.target.value);
        if (!hits.length){ sugg.classList.add('hidden'); sugg.innerHTML=''; return; }
        sugg.classList.remove('hidden');
        sugg.innerHTML = hits.map(h => `<button class="suggest px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-left" data-id="${h.id}" title="${h.name}">${h.id}</button>`).join('');
        sugg.querySelectorAll('.suggest').forEach(b => b.addEventListener('click', ()=>{
          epgInput.value = b.getAttribute('data-id');
          sugg.classList.add('hidden');
        }));
      });

      row.appendChild(left);
      row.appendChild(right);
      inner.appendChild(row);
      inner.appendChild(sugg);
    }

    body.appendChild(inner);
    wrap.appendChild(header);
    wrap.appendChild(body);
    header.addEventListener('click', ()=> body.classList.toggle('hidden'));
    host.appendChild(wrap);
  }
  bindBulkControls();
}

async function loadChannelsMapping({ page, limit, q, group } = {}){
  try {
    showLoading(true);
    ensurePagerBar();

    if (typeof q === 'string') FILTERS.q = q;
    if (typeof group === 'string') FILTERS.group = group;

    const p = Number(page ?? PAGING.page ?? 1);
    const l = Number(limit ?? PAGING.limit ?? 100);

    const u = new URL('/api/channels', location.origin);
    u.searchParams.set('page', String(p));
    u.searchParams.set('limit', String(l));
    if (FILTERS.q)     u.searchParams.set('q', FILTERS.q);
    if (FILTERS.group) u.searchParams.set('group', FILTERS.group);

    const r = await fetch(u, { cache: 'no-cache' });
    const payload = await r.json();
    const rows = Array.isArray(payload) ? payload
               : Array.isArray(payload?.rows) ? payload.rows
               : [];

    PAGING.page  = Number((Array.isArray(payload) ? p : payload?.page)  ?? p);
    PAGING.limit = Number((Array.isArray(payload) ? l : payload?.limit) ?? l);
    PAGING.total = Number((Array.isArray(payload) ? rows.length : payload?.total) ?? rows.length);
    PAGING.pages = Math.max(1, Math.ceil(PAGING.total / Math.max(1, PAGING.limit)));

    ALL_CH = rows.map(ch => ({
      id: ch.id ?? ch.channel_id ?? ch.stream_id ?? null,
      name: ch.name ?? ch.channelName ?? 'Channel',
      group_name: ch.group_name ?? ch.group ?? ch.category_name ?? '',
      tvg_id: ch.tvg_id ?? ch.epg_channel_id ?? '',
      logo: ch.logo ?? ch.tvg_logo ?? '',
      number: (ch.number != null) ? Number(ch.number) : null,
      url: ch.url ?? ch.stream_url ?? '',
      enabled: ch.enabled ?? ch.enable ?? false,
      epg_source: ch.epg_source ?? null,
    })).filter(ch => ch.url);

    updatePagerUI();
    ensureGroupOptions();
    renderGrouped(ALL_CH); // <— nur rendern
  } catch(e){
    console.error(e);
    ALL_CH = [];
    renderGrouped(ALL_CH);
  } finally {
    showLoading(false);
  }
}

async function loadLeft(){
  if (window.DRAG_LOCK) return;
  const { page, limit, q, group } = LEFT_STATE;
  const res = await fetchChannelsRobust({ page, limit, q, group });
  LEFT_STATE.page = res.page; LEFT_STATE.limit = res.limit;
  LEFT_STATE.total = res.total; LEFT_ROWS = res.rows;
  renderDualPane(); // rendert beide Spalten
}

async function loadRight(){
  if (window.DRAG_LOCK) return;
  const { page, limit, q } = RIGHT_STATE;
  // enabled=1 erwartet (Server-Patch unten). Fallback: filter client-side (falls Server noch nicht kann)
  const res = await fetchChannelsRobust({ page, limit, q, enabled: 1 });
  RIGHT_STATE.page = res.page; RIGHT_STATE.limit = res.limit;
  RIGHT_STATE.total = res.total || res.rows.length;
  RIGHT_ROWS = res.rows.filter(c => c.enabled === true || c.enabled === 1);
  renderDualPane();
}

// einmalige Initialisierung beim Betreten der Mapping-Seite
async function initDualPaneMapping(){
  setViewMode('dual');
  // Seite 1 beider Spalten laden
  await Promise.all([loadLeft(), loadRight()]);
}

function getSelectedIds(){
  return Array.from(document.querySelectorAll('.rowSelect:checked')).map(x => Number(x.getAttribute('data-id')));
}

function bindBulkControls(){
  const selAll = document.getElementById('selectAll');
  const bulkEn = document.getElementById('bulkEnable');
  const bulkDis = document.getElementById('bulkDisable');
  const bulkNum = document.getElementById('bulkRenumber');
  selAll?.addEventListener('change', ()=>{
    const on = selAll.checked;
    document.querySelectorAll('.rowSelect').forEach(cb => { cb.checked = on; });
  });
  bulkEn?.addEventListener('click', async ()=>{
    const ids = getSelectedIds(); if (!ids.length) return showToast('Keine Kanäle ausgewählt','warn');
    await fetchJSON('/api/channels/bulk', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ ids, action:'enable' })
    });
    showToast('Aktiviert');
    await loadChannelsMapping();
  });
  bulkDis?.addEventListener('click', async ()=>{
    const ids = getSelectedIds(); if (!ids.length) return showToast('Keine Kanäle ausgewählt','warn');
    await fetchJSON('/api/channels/bulk', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ ids, action:'disable' })
    });
    showToast('Deaktiviert');
    await loadChannelsMapping();
  });
  bulkNum?.addEventListener('click', async ()=>{
    const ids = getSelectedIds(); if (!ids.length) return showToast('Keine Kanäle ausgewählt','warn');
    const start = Number(document.getElementById('startNumber')?.value || 0);
    await fetchJSON('/api/channels/bulk', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ ids, action:'renumber', startNumber: start })
    });
    showToast('Nummern gesetzt');
    await loadChannelsMapping();
  });
}

document.addEventListener('DOMContentLoaded', async ()=>{
  try {
    // Bind UI
    const newBtn = document.getElementById('newM3uBtn');
    const m3uForm = document.getElementById('m3uForm');
    newBtn?.addEventListener('click', (e)=>{ e.preventDefault(); m3uForm?.classList.toggle('hidden'); });

    document.getElementById('refreshBtn')?.addEventListener('click', async ()=>{
      try {
        showLoading(true);
        const p = fetchJSON('/api/refresh', { method:'POST' });
        const timer = setInterval(async ()=>{
          try{
            const s = await fetchJSON('/api/epg/status');
            if (s.running){
              const txt = s.phase==='download' ? `EPG: ${s.current}/${s.total}` : (`EPG: ${s.phase||''}`);
              showToast(txt);
            }
          } catch(_){}
        }, 1500);
        await p;
        clearInterval(timer);
        await loadChannelsMapping();
        await loadEPGSources();
        showToast('Refresh abgeschlossen');
      } catch(e){
        showToast(e.message || 'Refresh fehlgeschlagen', 'error');
      } finally { showLoading(false); }
    });

    const m3uFormEl = document.getElementById('m3uForm');
    m3uFormEl?.addEventListener('submit', async (e)=>{
      e.preventDefault();
      try {
        showLoading(true);
        const fd = new FormData(m3uFormEl);
        await fetchJSON('/api/sources/m3u', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify(Object.fromEntries(fd.entries()))
        });
        m3uFormEl.reset();
        await loadSources();
        await loadChannelsMapping();
        await checkWizard();
        showToast('M3U hinzugefügt & aktualisiert');
      } catch (err){
        showToast(err.message || 'Fehler beim Hinzufügen', 'error');
      } finally { showLoading(false); }
    });

    const xtForm = document.getElementById('xtreamForm');
    xtForm?.addEventListener('submit', async (e)=>{
      e.preventDefault();
      try {
        showLoading(true);
        const fd = new FormData(xtForm);
        await fetchJSON('/api/sources/xtream', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify(Object.fromEntries(fd.entries()))
        });
        xtForm.reset();
        await loadSources();
        await loadChannelsMapping();
        await checkWizard();
        showToast('Xtream hinzugefügt & aktualisiert');
      } catch (err){
        showToast(err.message || 'Fehler beim Hinzufügen', 'error');
      } finally { showLoading(false); }
    });

    const epgForm = document.getElementById('epgForm');
    epgForm?.addEventListener('submit', async (e)=>{
      e.preventDefault();
      try {
        showLoading(true);
        const fd = new FormData(epgForm);
        await fetchJSON('/api/epg', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify(Object.fromEntries(fd.entries()))
        });
        epgForm.reset();
        await loadEPGSources();
        await checkWizard();
        showToast('EPG hinzugefügt');
      } catch (err){
        showToast(err.message || 'Fehler beim Hinzufügen', 'error');
      } finally { showLoading(false); }
    });

    document.getElementById('wizardClose')?.addEventListener('click', ()=> document.getElementById('setupWizard')?.classList.add('hidden'));

    document.getElementById('searchBox')?.addEventListener('input', applyFilterAndSearch);
    document.getElementById('groupFilter')?.addEventListener('change', applyFilterAndSearch);

    window.addEventListener('hashchange', async ()=>{
      const page = (location.hash.replace('#/','')||'playlist');
      if (page === 'mapping'){ await loadEPGIndex(); await initDualPaneMapping(); }
      if (page === 'xmltv'){ await loadEPGSources(); }
    });

    await loadSources();
    await loadEPGIndex();
    await loadEPGSources();
    // await loadChannelsMapping({ page: 1 }); // nur Seite 1 laden
    await initDualPaneMapping();
    await checkWizard();
  } catch (e){
    console.error(e);
    showToast('Init error: '+ (e.message||e), 'error');
  }
});

// ==== DND / State falls noch nicht vorhanden ====
window.DND = window.DND || { draggingId: null };
window.RIGHT_ROWS = window.RIGHT_ROWS || [];
window.LEFT_ROWS  = window.LEFT_ROWS  || [];


async function disableChannel(id){
  try {
    await fetchJSON('/api/channels/'+id, {
      method:'PATCH',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ enabled: false })
    });
    showToast('Entfernt');
    await Promise.all([loadLeft(), loadRight()]);
  } catch (e){
    console.error(e);
    showToast('Konnte nicht entfernen','error');
  }
}

// ==== Drag & Drop Utilities (rechte Liste) ====
function getDropIndex(container, evt){
  const items = Array.from(container.children);
  const y = evt.clientY;
  let idx = items.length;
  for (let i=0;i<items.length;i++){
    const rect = items[i].getBoundingClientRect();
    if (y < rect.top + rect.height/2){ idx = i; break; }
  }
  return idx;
}

function reorderRight(id, dropIndex){
  const i = RIGHT_ROWS.findIndex(x => x.id === id);
  if (i < 0) return;
  const target = Math.min(Math.max(dropIndex, 0), RIGHT_ROWS.length-1);
  if (i === target) return; // nichts zu tun
  const [item] = RIGHT_ROWS.splice(i, 1);
  RIGHT_ROWS.splice(target, 0, item);
  renderDualPane();
}


// ==== Reihenfolge speichern (rechte Liste) ====
async function saveRightOrder(){
  const start = Number(document.getElementById('startNumberDual')?.value || 1);
  const ids = RIGHT_ROWS.map(x => x.id);
  if (!ids.length) return showToast('Keine Einträge rechts','warn');
  try{
    await fetchJSON('/api/channels/bulk', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ ids, action:'renumber', startNumber: start })
    });
    showToast('Reihenfolge gespeichert');
    await Promise.all([loadLeft(), loadRight()]);
  }catch(e){
    console.error(e);
    showToast('Renumber fehlgeschlagen','error');
  }
}

function ensureDropMarker(container){
  let marker = container.querySelector('#dropMarker');
  if (!marker){
    marker = document.createElement('div');
    marker.id = 'dropMarker';
    marker.className = 'h-0.5 bg-indigo-500 mx-2 rounded hidden';
  }
  return marker;
}
 
function ensureDropMarker(container){
  let marker = container.querySelector('#dropMarker');
  if (!marker){
    marker = document.createElement('div');
    marker.id = 'dropMarker';
    marker.className = 'h-0.5 bg-indigo-500 mx-2 rounded hidden';
  }
  return marker;
}

function clearMarker(marker){ 
  if (marker) marker.classList.add('hidden'); 
}

function setMarkerAt(container, marker, beforeNode){
  if (beforeNode) container.insertBefore(marker, beforeNode);
  else container.appendChild(marker);
  marker.classList.remove('hidden');
}

function computeIndexFromMarker(container, marker){
  // Index = Anzahl rechter Zeilen (.rightRow) vor dem Marker
  const kids = Array.from(container.children);
  let idx = 0;
  for (const el of kids){
    if (el === marker) return idx;
    if (el.classList && el.classList.contains('rightRow')) idx++;
  }
  return idx;
}


// ===== Dual-Pane Renderer =====
function renderDualPane(){
  const host = document.getElementById('groupedChannels');
  if (!host) return;

  host.innerHTML = `
  <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
    <!-- LEFT: Quelle -->
    <div class="rounded-2xl border border-slate-800 overflow-hidden">
      <div class="bg-slate-900 px-3 py-2 flex items-center gap-2">
        <div class="font-semibold">Quelle (Xtream / M3U)</div>
        <div class="ml-auto flex items-center gap-2">
          <input id="leftSearch" class="px-3 py-2 rounded bg-slate-800 text-sm w-40" placeholder="Suche Quelle…" value="${LEFT_STATE.q.replace(/"/g,'&quot;')}" />
          <select id="leftPageSize" class="px-2 py-1 rounded bg-slate-800 text-sm">
            <option ${LEFT_STATE.limit==50?'selected':''} value="50">50</option>
            <option ${LEFT_STATE.limit==100?'selected':''} value="100">100</option>
            <option ${LEFT_STATE.limit==200?'selected':''} value="200">200</option>
          </select>
          <button id="leftPrev" class="px-3 py-1 rounded bg-slate-800 hover:bg-slate-700">◀</button>
          <span class="text-slate-300 text-sm" id="leftInfo"></span>
          <button id="leftNext" class="px-3 py-1 rounded bg-slate-800 hover:bg-slate-700">▶</button>
        </div>
      </div>
      <div id="leftList" class="bg-slate-900/50 divide-y divide-slate-800 min-h-[320px]"></div>
    </div>

    <!-- RIGHT: Ausgewählt/Enabled -->
    <div class="rounded-2xl border border-slate-800 overflow-hidden">
      <div class="bg-slate-900 px-3 py-2 flex items-center gap-2">
        <div class="font-semibold">Ausgewählt (Enabled)</div>
        <div class="ml-auto flex items-center gap-2">
          <input id="rightSearch" class="px-3 py-2 rounded bg-slate-800 text-sm w-40" placeholder="Suche Enabled…" value="${RIGHT_STATE.q.replace(/"/g,'&quot;')}" />
          <select id="rightPageSize" class="px-2 py-1 rounded bg-slate-800 text-sm">
            <option ${RIGHT_STATE.limit==50?'selected':''} value="50">50</option>
            <option ${RIGHT_STATE.limit==100?'selected':''} value="100">100</option>
            <option ${RIGHT_STATE.limit==200?'selected':''} value="200">200</option>
          </select>
          <button id="rightPrev" class="px-3 py-1 rounded bg-slate-800 hover:bg-slate-700">◀</button>
          <span class="text-slate-300 text-sm" id="rightInfo"></span>
          <button id="rightNext" class="px-3 py-1 rounded bg-slate-800 hover:bg-slate-700">▶</button>
        </div>
      </div>
      <div id="rightList" class="bg-slate-900/50 divide-y divide-slate-800 min-h-[320px]"></div>

      <div class="bg-slate-900/70 px-3 py-2 flex items-center gap-2">
        <label class="text-xs text-slate-300">Startnummer:</label>
        <input id="startNumberDual" class="px-2 py-1 rounded bg-slate-800 text-sm w-24" placeholder="z.B. 100" />
        <button id="saveOrder" class="px-3 py-2 rounded bg-indigo-600 hover:bg-indigo-500 text-sm">Reihenfolge speichern</button>
      </div>
    </div>
  </div>
  `;

  // Infos
  const leftInfo  = document.getElementById('leftInfo');
  const rightInfo = document.getElementById('rightInfo');
  leftInfo.textContent  = `Seite ${LEFT_STATE.page} / ${Math.max(1, Math.ceil((LEFT_STATE.total||0)/LEFT_STATE.limit))} • ${LEFT_STATE.total||0} Einträge`;
  rightInfo.textContent = `Seite ${RIGHT_STATE.page} / ${Math.max(1, Math.ceil((RIGHT_STATE.total||0)/RIGHT_STATE.limit))} • ${RIGHT_STATE.total||0} Einträge`;

  // LEFT list
  const leftHost = document.getElementById('leftList');
  LEFT_ROWS.forEach(ch => {
    const row = document.createElement('div');
    row.className = 'rightRow p-2 flex items-start justify-between gap-2';
    row.draggable = true;
    row.dataset.id = ch.id;
    row.addEventListener('dragstart', (e)=>{
      window.DRAG_LOCK = true;
      document.body.classList.add('select-none');
      DND.draggingId = ch.id;
      DND.source = 'left';
      DND.item = ch;
      try { e.dataTransfer.setData('text/plain', String(ch.id)); } catch {}
      e.dataTransfer.effectAllowed = 'copy';
    });
    row.addEventListener('dragend', ()=>{
      window.DRAG_LOCK = false;
      document.body.classList.remove('select-none');
    });

    row.innerHTML = `
      <div class="flex items-center gap-3 min-w-0">
        <img src="${ch.logo||''}" onerror="this.style.display='none'" class="w-6 h-6 rounded shrink-0" />
        <div class="min-w-0">
          <div class="truncate text-sm font-medium">${ch.name}</div>
          <div class="text-xs text-slate-400 truncate">${ch.group_name||''}</div>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button class="enableBtn px-2 py-1 rounded bg-emerald-700 hover:bg-emerald-600 text-xs">Hinzufügen</button>
      </div>
    `;
    row.querySelector('.enableBtn').addEventListener('click', ()=> enableChannel(ch.id));
    leftHost.appendChild(row);
  });

  // RIGHT list
  const rightHost = document.getElementById('rightList');
  const dropMarker = ensureDropMarker(rightHost);
  rightHost.appendChild(dropMarker);
  clearMarker(dropMarker);

  // Container: copy (von links) oder move (innen)
  rightHost.addEventListener('dragover', (e)=>{
    e.preventDefault();
    const y = e.clientY;
    const rows = Array.from(rightHost.querySelectorAll('.rightRow'));
    let beforeNode = null;
    for (const el of rows){
      const r = el.getBoundingClientRect();
      const mid = r.top + r.height/2;
      if (y < mid){ beforeNode = el; break; }
    }
    setMarkerAt(rightHost, dropMarker, beforeNode);
    DND.dropIndex = computeIndexFromMarker(rightHost, dropMarker);
    e.dataTransfer.dropEffect = (DND.source === 'right') ? 'move' : 'copy';
  });

  rightHost.addEventListener('dragleave', ()=>{
    // optional: Marker ausblenden, wenn Cursor rausgeht
    // clearMarker(dropMarker);
  });

  rightHost.addEventListener('drop', async (e)=>{
    e.preventDefault();
    const id = Number(DND.draggingId);
    const insertAt = (typeof DND.dropIndex === 'number') ? DND.dropIndex : RIGHT_ROWS.length;

    if (DND.source === 'left' && id){
      await enableChannel(id, insertAt); // fügt hinzu & lokal einsortiert (siehe unten)
    } else if (DND.source === 'right' && id){
      reorderRight(id, insertAt);       // lokal umsortieren
    }

    clearMarker(dropMarker);
    window.DRAG_LOCK = false;
    document.body.classList.remove('select-none');
    DND.draggingId = null; DND.source = null; DND.dropIndex = null; DND.item = null;
  });


  RIGHT_ROWS.forEach((ch) => {
    const row = document.createElement('div');
    row.className = 'p-2 flex items-start justify-between gap-2';
    row.draggable = true;
    row.dataset.id = ch.id;

    row.addEventListener('dragstart', (e)=>{
      window.DRAG_LOCK = true;
      document.body.classList.add('select-none');
      DND.draggingId = ch.id;
      DND.source = 'right';
      DND.item = ch;
      try { e.dataTransfer.setData('text/plain', String(ch.id)); } catch {}
      e.dataTransfer.effectAllowed = 'move';
    });
    row.addEventListener('dragend', ()=>{
      window.DRAG_LOCK = false;
      document.body.classList.remove('select-none');
      clearMarker(dropMarker);
      DND.draggingId = null; DND.source = null; DND.dropIndex = null; DND.item = null;
    });

    row.addEventListener('dragover', (e)=>{
      e.preventDefault();
      const r = row.getBoundingClientRect();
      const before = e.clientY < (r.top + r.height/2);
      setMarkerAt(rightHost, dropMarker, before ? row : row.nextSibling);
      DND.dropIndex = computeIndexFromMarker(rightHost, dropMarker);
      e.dataTransfer.dropEffect = 'move';
    });
    row.addEventListener('drop', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      const insertAt = (typeof DND.dropIndex === 'number') ? DND.dropIndex : RIGHT_ROWS.length;
      reorderRight(ch.id, insertAt);
      clearMarker(dropMarker);
    });

    row.addEventListener('drop', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      const insertAt = DND.dropIndex ?? RIGHT_ROWS.length;
      reorderRight(ch.id, insertAt);
      clearMarker(dropMarker);
      DND.draggingId = null;
      DND.source = null;
      DND.dropIndex = null;
      DND.item = null;
    });

    row.innerHTML = `
      <div class="flex items-center gap-3 min-w-0">
        <div class="cursor-move select-none text-slate-400">☰</div>
        <img src="${ch.logo||''}" onerror="this.style.display='none'" class="w-6 h-6 rounded shrink-0" />
        <div class="min-w-0">
          <div class="truncate text-sm font-medium">${ch.name}</div>
          <div class="text-xs text-slate-400 truncate">${ch.group_name||''}</div>
        </div>
      </div>
      <div class="flex flex-col items-end gap-2">
        <div class="flex items-center gap-2">
          <button class="disableBtn px-2 py-1 rounded bg-red-700 hover:bg-red-600 text-xs">Entfernen</button>
        </div>
        <div class="flex items-center gap-2">
          <select class="epgSourceSel px-2 py-1 rounded bg-slate-800 text-xs">
            <option value="">Auto/Global</option>
          </select>
          <input type="text" placeholder="EPG-ID suchen…" class="epgSearch px-2 py-1 rounded bg-slate-800 text-xs w-40" />
          <button class="assignBtn px-2 py-1 rounded bg-indigo-600 hover:bg-indigo-500 text-xs">Zuweisen</button>
        </div>
        <div class="epgSugg grid grid-cols-2 gap-2 w-full hidden"></div>
        <div class="text-[11px] ${ch.tvg_id ? 'text-emerald-400' : 'text-amber-400'}">
          EPG: <span class="epgCurrent">${ch.tvg_id || '— nicht zugeordnet —'}</span>
        </div>
      </div>
    `;

    // EPG-UI verdrahten
    const disableBtn = row.querySelector('.disableBtn');
    const epgSel     = row.querySelector('.epgSourceSel');
    const epgInput   = row.querySelector('.epgSearch');
    const epgSugg    = row.querySelector('.epgSugg');
    const assignBtn  = row.querySelector('.assignBtn');
    const epgCurrent = row.querySelector('.epgCurrent');

    (async ()=>{
      try {
        const list = await getEpgSourcesCached();
        for (const it of list){
          const opt = document.createElement('option');
          opt.value = it.name; opt.textContent = it.name;
          epgSel.appendChild(opt);
        }
        if (ch.epg_source){ epgSel.value = ch.epg_source; }
      } catch {}
    })();

    disableBtn.addEventListener('click', ()=> disableChannel(ch.id));

    const debLoc = (fn, ms=250)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };
    epgInput.addEventListener('input', debLoc((e)=>{
      const hits = epgSuggest(e.target.value);
      if (!hits.length){ epgSugg.classList.add('hidden'); epgSugg.innerHTML=''; return; }
      epgSugg.classList.remove('hidden');
      epgSugg.innerHTML = hits.map(h =>
        `<button class="suggest px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-left text-xs" data-id="${h.id}" title="${h.name}">${h.id}</button>`
      ).join('');
      epgSugg.querySelectorAll('.suggest').forEach(b => b.addEventListener('click', ()=>{
        epgInput.value = b.getAttribute('data-id');
        epgSugg.classList.add('hidden');
      }));
    }, 250));

    const doAssign = async ()=>{
      const tvg = (epgInput.value||'').trim();
      const src = (epgSel.value||'') || null;
      if (!tvg){ showToast('Bitte EPG-ID wählen/ eintippen', 'warn'); return; }
      try{
        await fetchJSON('/api/channels/'+ch.id+'/assign-epg', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ tvg_id: tvg, epg_source: src })
        });
        epgCurrent.textContent = tvg;
        showToast('EPG zugewiesen');
        await loadRight();
      }catch(e){
        showToast('EPG-Zuweisung fehlgeschlagen', 'error');
      }
    };
    assignBtn.addEventListener('click', doAssign);
    epgInput.addEventListener('keydown', (e)=>{ if (e.key==='Enter') doAssign(); });

    rightHost.appendChild(row);
  });

  // Pager & Suche
  document.getElementById('leftPrev').onclick  = ()=> { if (LEFT_STATE.page>1){ LEFT_STATE.page--; loadLeft(); } };
  document.getElementById('leftNext').onclick  = ()=> { const max = Math.max(1, Math.ceil((LEFT_STATE.total||0)/LEFT_STATE.limit)); if (LEFT_STATE.page<max){ LEFT_STATE.page++; loadLeft(); } };
  document.getElementById('rightPrev').onclick = ()=> { if (RIGHT_STATE.page>1){ RIGHT_STATE.page--; loadRight(); } };
  document.getElementById('rightNext').onclick = ()=> { const max = Math.max(1, Math.ceil((RIGHT_STATE.total||0)/RIGHT_STATE.limit)); if (RIGHT_STATE.page<max){ RIGHT_STATE.page++; loadRight(); } };

  document.getElementById('leftPageSize').onchange  = (e)=>{ LEFT_STATE.limit = Number(e.target.value)||100; LEFT_STATE.page = 1; loadLeft(); };
  document.getElementById('rightPageSize').onchange = (e)=>{ RIGHT_STATE.limit = Number(e.target.value)||100; RIGHT_STATE.page = 1; loadRight(); };

  const deb = (fn, ms=250)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; };
  document.getElementById('leftSearch').oninput  = deb((e)=>{ LEFT_STATE.q = e.target.value.trim(); LEFT_STATE.page=1; loadLeft(); });
  document.getElementById('rightSearch').oninput = deb((e)=>{ RIGHT_STATE.q = e.target.value.trim(); RIGHT_STATE.page=1; loadRight(); });

  document.getElementById('saveOrder').onclick = saveRightOrder;
}

async function enableChannel(id, dropIndex){
  try {
    await fetchJSON('/api/channels/'+id, {
      method:'PATCH',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ enabled: true })
    });
    showToast('Hinzugefügt');

    // NICHT sofort loadRight() (würde Reihenfolge überschreiben), 
    // sondern einmalig laden und dann lokal an die Position setzen.
    if (!window.DRAG_LOCK) { await loadRight(); } // falls kein Drag aktiv
    else { await loadRight(); } // wir brauchen die aktuelle Datenbasis zum Einfügen

    if (typeof dropIndex === 'number'){
      const i = RIGHT_ROWS.findIndex(x => x.id === id);
      if (i >= 0){
        const [item] = RIGHT_ROWS.splice(i, 1);
        RIGHT_ROWS.splice(Math.min(Math.max(dropIndex,0), RIGHT_ROWS.length), 0, item);
        renderDualPane();
      }
    }
  } catch (e){
    console.error(e);
    showToast('Konnte nicht hinzufügen','error');
  }
}
